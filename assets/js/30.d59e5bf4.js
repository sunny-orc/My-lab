(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{174:function(e,n,t){"use strict";t.r(n);var r=t(0),a=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"es6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6","aria-hidden":"true"}},[e._v("#")]),e._v(" ES6")]),e._v(" "),t("h2",{attrs:{id:"箭头函数与this（arrows-and-lexical-this）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数与this（arrows-and-lexical-this）","aria-hidden":"true"}},[e._v("#")]),e._v(" 箭头函数与this（Arrows and Lexical This）")]),e._v(" "),t("p",[t("strong",[e._v("所有的箭头函数都没有自己的this，都指向外层")]),e._v("，"),t("strong",[e._v("箭头函数与包裹它的代码共享相同的this对象")]),e._v("，如果箭头函数在其他函数的内部，它将共享该函数的arguments变量。")]),e._v(" "),t("p",[e._v("“箭头函数”的"),t("code",[e._v("this")]),e._v("，"),t("strong",[e._v("总是指向定义时所在的对象")]),e._v("，而不是运行时所在的对象。还有一种描述"),t("strong",[e._v("总是指向所在函数运行时的this")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// demo1\nvar a = {\n    name: 'A',\n    fn: function () {\n        console.log(this)\n    },\n    fnArrow: () => console.log(this)\n}\na.fn()  // {name: \"A\", fn: ƒ, fnArrow: ƒ}\na.fnArrow() // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …} 因为箭头函数指向定义时的对象，此时定义在window，指向window\na.fn.call({name: 'B'})  // {name: \"B\"}\na.fnArrow.call({name: 'B'}) // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …} 因为箭头函数指向定义时的对象，此时定义在window，指向window\nvar fn1 = a.fn\nfn1()  // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\nvar fn2 = a.fnArrow\nfn2() // Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …} 因为箭头函数指向定义时的对象，此时定义在window，指向window\n\n// demo2\nfunction fn() {\n    console.log('real', this)\n    var arr = [1, 2, 3]\n    // 普通 JS\n    arr.map(function (item) {\n        console.log('js', this)\n        return item + 1\n    })\n    // 箭头函数\n    arr.map(item => {\n        console.log('es6', this)\n        return item + 1\n    })\n}\nfn.call({a: 100})\n输出如下：\n    real {a: 100}\n    js Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\n    js Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\n    js Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\n    es6 {a: 100}\n    es6 {a: 100}\n    es6 {a: 100}\nfn()\n输出如下：\n\treal Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\n\tjs Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\n\tjs Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\n\tjs Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\n\tes6 Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\n\tes6 Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\n\tes6 Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …}\n因为 fn函数只有运行后，箭头函数才会按照定义生成this指向，因此此时箭头函数定义时的所在对象恰好是fn运行时所在的对象。上例中的两个输出，第一个输出，因为fn运行时所指向的对象是{a: 100},因此箭头函数的定义时指向也为{a: 100};第二个输出，因为fn运行时所指向的对象是window，因此箭头函数的定义时指向也为window\n\n// demo3\nfunction foo() {\n  return () => {\n    return () => {\n      return () => {\n        console.log(\"id:\", this.id);\n      };\n    };\n  };\n}\n\nvar f = foo.call({id: 1});\n\nvar t1 = f.call({id: 2})()();\nvar t2 = f().call({id: 3})();\nvar t3 = f()().call({id: 4});\n\n输出：\nid: 1\nid: 1\nid: 1\n原因很简单 因为f在运行时已经确定了此时的箭头函数的定义时指向，接下来的运行时的变化将不会影响this的指向\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// this 对象\nvar bob = {\n    _name: "Bob",\n    _friends: [],\n    printFriends() {\n        this._friends.forEach(f => console.log(this._name + " knows " + f));\n    }\n}\n\n// arguments 对象\nfunction square() {\n    let example = () => {\n        let numbers = [];\n        for (let number of arguments) {\n            numbers.push(number * number);\n        }\n        return numbers;\n    };\n    return example();\n};\n\nsquare(2, 4, 7.5, 8); // returns: [4, 16, 56,25, 64]\n')])])]),t("h2",{attrs:{id:"类（classes）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类（classes）","aria-hidden":"true"}},[e._v("#")]),e._v(" 类（Classes）")]),e._v(" "),t("p",[e._v("语法糖。类支持基于原型的继承，调用父类的构造函数，生成实例，静态方法和构造函数")]),e._v(" "),t("h2",{attrs:{id:"增强的对象字面量（enhanced-object-literials）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#增强的对象字面量（enhanced-object-literials）","aria-hidden":"true"}},[e._v("#")]),e._v(" 增强的对象字面量（Enhanced Object Literials）")]),e._v(" "),t("p",[e._v("允许在结构中设置原型，简化foo: foo 这样的赋值，定义方法和调用父级。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var obj = {\n    // 设置 prototype\n    __proto__: theProtoObj,\n    // 计算属性不会重复设置__proto__,或者将直接出发错误\n    ['__proto__']: somethingElse,\n    // 'handler: handler' 简写\n    handler,\n    // 方法\n    toString() {\n        // 调用父级方法\n        return \"d \" + super.toString();\n    },\n    // 设置动态的属性名\n    [ \"prop_\" + (() => 42)() ]: 42 \n}\n")])])]),t("h2",{attrs:{id:"模板字符串（template-strings）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模板字符串（template-strings）","aria-hidden":"true"}},[e._v("#")]),e._v(" 模板字符串（Template Strings）")]),e._v(" "),t("h2",{attrs:{id:"解构（destructuring）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解构（destructuring）","aria-hidden":"true"}},[e._v("#")]),e._v(" 解构（Destructuring）")]),e._v(" "),t("p",[e._v("解构允许使用模式匹配的方式进行绑定，并支持匹配数组和对象。解构具有一定的容错机制，就像查找普通对象foo['foo']，当没有找到时会返回undefined（而不会直接报错）")]),e._v(" "),t("blockquote",[t("p",[e._v("注：当上层结构都不存在时，解构会报错，如const [{id: id}] = [],解构数组为空，导致整个obj为undefined，此时再去找obj.id就会报错")])]),e._v(" "),t("h2",{attrs:{id:"默认参数（default）-不定参数（rest）-扩展运算符（spread）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认参数（default）-不定参数（rest）-扩展运算符（spread）","aria-hidden":"true"}},[e._v("#")]),e._v(" 默认参数（Default）+不定参数（Rest）+扩展运算符（Spread）")]),e._v(" "),t("p",[e._v("默认参数（default）的功能是在函数被调用时对参数做自动估值")]),e._v(" "),t("p",[e._v("扩展运算符(spread)可以将数组转换为连续的参数")]),e._v(" "),t("p",[e._v("不定参数（rest）用在参数末尾，将最末尾的参数转换成数组，不定参数让我们不在需要arguments")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// default\nfunction f(x, y=12) {\n    return x + y;\n}\n\n// rest\nfunction f(x, ...y) {\n    return x * y.length;\n}\nf(3, "hello", true) // 6\n\n//spread\nfunction (x, y, z) {\n    return x + y + z;\n}\nf(...[1, 2, 3]) == 6\n')])])]),t("h2",{attrs:{id:"定义变量（let）-定义常量（const）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义变量（let）-定义常量（const）","aria-hidden":"true"}},[e._v("#")]),e._v(" 定义变量（Let）+定义常量（Const）")]),e._v(" "),t("h2",{attrs:{id:"迭代器（iterators）-for-of循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#迭代器（iterators）-for-of循环","aria-hidden":"true"}},[e._v("#")]),e._v(" 迭代器（Iterators）+For...Of循环")]),e._v(" "),t("blockquote",[t("p",[e._v("注：使用迭代器要引入Babel的polyfill")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let fibonacci = {\n    [Symbol.iterator]() {\n        let pre = 0, cur = 1;\n        return {\n            next() {\n                [pre, cur] =[cur, pre + cur];\n                return { done: false, value: cur }\n            }\n        }\n    }\n}\n\nfor (var n of fibonacci) {\n\t// 循环将在n > 1000时结束\n    if (n > 1000) break;\n    console.log(n);\n}\n")])])]),t("h2",{attrs:{id:"generators"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generators","aria-hidden":"true"}},[e._v("#")]),e._v(" Generators")]),e._v(" "),t("p",[e._v("通过使用function* 和yield关键字简化了迭代器的编写")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let fibonacci = {\n    [Symbol.iterator]: function*() {\n        let pre = 0, cur = 1;\n        for (;;) {\n            let temp = pre;\n            pre = cur;\n            cur += temp;\n            yield cur;\n        }\n    }\n}\n\nfor (var n of fibonacci) {\n\t// 循环将在n > 1000时结束\n    if (n > 1000) break;\n    console.log(n);\n}\n")])])]),t("blockquote",[t("p",[e._v("注：需要在项目中包含Babel的polyfill")])]),e._v(" "),t("h2",{attrs:{id:"模块（modules）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块（modules）","aria-hidden":"true"}},[e._v("#")]),e._v(" 模块（Modules）")]),e._v(" "),t("p",[e._v("由宿主环境的默认加载器定义模块运行时的行为，采取隐式异步模式—在模块可以被获取和加载前不会有代码执行")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function sum(){}\nexport var pi = xx\nexport default\nexport *\nimport * as math from 'xx'\nimport {sum, pi} from 'xx'\n")])])]),t("h2",{attrs:{id:"map-set-weakmap-weakset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map-set-weakmap-weakset","aria-hidden":"true"}},[e._v("#")]),e._v(" Map+Set+WeakMap+WeakSet")]),e._v(" "),t("p",[e._v("WeakMap和WeakSet的理解？")]),e._v(" "),t("p",[e._v("weakMaps提供了对对象的弱引用（不会被垃圾回收计数）")]),e._v(" "),t("blockquote",[t("p",[e._v("注：需要使用Babel的polyfill")])]),e._v(" "),t("h2",{attrs:{id:"代理对象（proxies）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代理对象（proxies）","aria-hidden":"true"}},[e._v("#")]),e._v(" 代理对象（Proxies）")]),e._v(" "),t("p",[e._v("需理解。。")]),e._v(" "),t("p",[e._v("proxies允许创建一个可以全范围控制宿主对象行为的对象，可用于拦截，对象的虚拟化，日志记录/性能分析等")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 代理普通对象\nvar target = {}\nvar handler = {\n    get: function(receiver, name) {\n        return `hello, ${name}`;\n    }\n}\nvar p = new Proxy(target, handler)\np.world === "hello, world"\n\n// 代理函数对象\nvar target = function() {return "I am the target";}\nvar handler = {\n    apply: function(receiver, ...args) {\n        return "I am the proxy"\n    }\n}\nvar p = new Proxy(target, handler)\np() === "I am the proxy"\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 所有元操作(meta-operations)\nvar handler =\n{\n  // target.prop\n  get: ...,\n  // target.prop = value\n  set: ...,\n  // 'prop' in target\n  has: ...,\n  // delete target.prop\n  deleteProperty: ...,\n  // target(...args)\n  apply: ...,\n  // new target(...args)\n  construct: ...,\n  // Object.getOwnPropertyDescriptor(target, 'prop')\n  getOwnPropertyDescriptor: ...,\n  // Object.defineProperty(target, 'prop', descriptor)\n  defineProperty: ...,\n  // Object.getPrototypeOf(target), Reflect.getPrototypeOf(target),\n  // target.__proto__, object.isPrototypeOf(target), object instanceof target\n  getPrototypeOf: ...,\n  // Object.setPrototypeOf(target), Reflect.setPrototypeOf(target)\n  setPrototypeOf: ...,\n  // for (let i in target) {}\n  enumerate: ...,\n  // Object.keys(target)\n  ownKeys: ...,\n  // Object.preventExtensions(target)\n  preventExtensions: ...,\n  // Object.isExtensible(target)\n  isExtensible :...\n}\n")])])]),t("blockquote",[t("p",[e._v("注：由于ES5的局限性，Proxies无法被转换或者通过polyfill兼容")])]),e._v(" "),t("h2",{attrs:{id:"symbols"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#symbols","aria-hidden":"true"}},[e._v("#")]),e._v(" Symbols")]),e._v(" "),t("p",[e._v("需理解。。")]),e._v(" "),t("p",[e._v("Symbol对对象的状态进行访问控制")]),e._v(" "),t("blockquote",[t("p",[e._v("注：通过polyfill部分实现：")]),e._v(" "),t("p",[e._v("部分功能不能转换或通过polyfill兼容")])]),e._v(" "),t("h2",{attrs:{id:"promises"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promises","aria-hidden":"true"}},[e._v("#")]),e._v(" Promises")]),e._v(" "),t("h2",{attrs:{id:"reflect-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reflect-api","aria-hidden":"true"}},[e._v("#")]),e._v(" Reflect API")]),e._v(" "),t("p",[e._v("需理解。。")])])}],!1,null,null,null);a.options.__file="review-the-javascript.md";n.default=a.exports}}]);