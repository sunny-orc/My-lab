(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{153:function(e,n,t){"use strict";t.r(n);var s=t(0),a=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue")]),e._v(" "),t("h2",{attrs:{id:"nexttick"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nexttick","aria-hidden":"true"}},[e._v("#")]),e._v(" NextTick")]),e._v(" "),t("h3",{attrs:{id:"前提"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前提","aria-hidden":"true"}},[e._v("#")]),e._v(" 前提")]),e._v(" "),t("p",[e._v("在vue2.4之前都是使用microtasks，但由于microtasks的优先级过高，在某些情况下会出现比事件冒泡更快的情况，但如果都使用macrotasks又可能出现渲染的性能问题。所以在新版本中，会默认使用microtasks，但是在特殊情况下会用macrotasks，如v-on")]),e._v(" "),t("p",[e._v("实现macrotasks，"),t("strong",[e._v("会先判断是否能使用setImmediate，不能的话降级为MessageChannel，以上都不行的话使用setTimeout")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    macroTimerFunc = () => {\n        setImmediate(flushCallbacks);\n    }\n} else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) || MessageChannel.toString() === '[object MessageChannelConstructor]')) {\n    const channel = new MessageChannel();\n    const port = channel.port2;\n    channel.port1.onmessage = flushCallbacks;\n    macroTimerFunc = () => {\n        port.postMessage(1);\n    }\n} else {\n    macroTimerFunc = () => {\n        setTimeout(flushCallbacks, 0);\n    }\n}\n")])])]),t("p",[e._v("nextTick同时支持Promise的使用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function nextTick(cb?: Function, ctx?: Object) {\n  let _resolve\n  // 将回调函数整合进一个数组中\n  callbacks.push(() => {\n    if (cb) {\n      try {\n        cb.call(ctx)\n      } catch (e) {\n        handleError(e, ctx, 'nextTick')\n      }\n    } else if (_resolve) {\n      _resolve(ctx)\n    }\n  })\n  if (!pending) {\n    pending = true\n    if (useMacroTask) {\n      macroTimerFunc()\n    } else {\n      microTimerFunc()\n    }\n  }\n  // 判断是否可以使用 Promise \n  // 可以的话给 _resolve 赋值\n  // 这样回调函数就能以 promise 的方式调用\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(resolve => {\n      _resolve = resolve\n    })\n  }\n}\n")])])])])}],!1,null,null,null);a.options.__file="Damn-hole-of-Vue.md";n.default=a.exports}}]);