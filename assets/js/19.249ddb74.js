(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{163:function(e,t,a){"use strict";a.r(t);var n=a(0),r=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"mvvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm","aria-hidden":"true"}},[e._v("#")]),e._v(" MVVM")]),e._v(" "),a("p",[e._v("由三部分组成")]),e._v(" "),a("ul",[a("li",[e._v("View：界面")]),e._v(" "),a("li",[e._v("Model：数据模型")]),e._v(" "),a("li",[e._v("ViewModel：作为桥梁负责沟通View和Model")])]),e._v(" "),a("p",[e._v("在MVVM中，最核心的就是数据双向绑定，例如ng的脏数据检测，vue中的数据劫持")]),e._v(" "),a("h2",{attrs:{id:"脏数据检测"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#脏数据检测","aria-hidden":"true"}},[e._v("#")]),e._v(" 脏数据检测")]),e._v(" "),a("p",[e._v("当触发了指定事件后会进入脏数据检测，这时会调用**$digest"),a("strong",[e._v("循环遍历所有的数据观察者，判断当前是否和先前的值有区别，如果检测到变化的话，会调用")]),e._v("$watch**函数，然后再次调用$digest循环到发现没有变化。循环至少为两次，至多为十次")]),e._v(" "),a("p",[e._v("赞数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在Vue中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再统一更新UI，大大减少操作DOM的次数。因此，低效也是相对的")]),e._v(" "),a("h2",{attrs:{id:"数据劫持"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据劫持","aria-hidden":"true"}},[e._v("#")]),e._v(" 数据劫持")]),e._v(" "),a("p",[e._v("Vue内部使用了Object.defineProperty()来实现双向数据绑定，通过函数可以监听到set和get的事件")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var data = { name: 'xl' };\nobserve(data);\nlet name = data.name;\ndata.name = 'yx';\n\nfunction obserse(obj) {\n    // 判断类型\n    if (!obj || typeof obj !== 'object') {\n        return;\n    }\n    Object.keys(data).forEach(key => {\n        defineReactive(data, key, data[key]);\n    })\n}\nfunction defineReactive(obj, key, val) {\n\t// 递归子属性\n    observe(val);\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: false,\n        set: function reactiveSetter (newVal) {\n            console.log('change value');\n            val = newVal;\n        },\n        get: function reactiveGetter () {\n            console.log('get value');\n            return val;\n        }\n    })\n}\n")])])]),a("h2",{attrs:{id:"proxy与object-defineproperty对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proxy与object-defineproperty对比","aria-hidden":"true"}},[e._v("#")]),e._v(" Proxy与Object.defineProperty对比")]),e._v(" "),a("p",[e._v("Object.defineProperty缺陷")]),e._v(" "),a("ol",[a("li",[e._v("只能对属性进行数据劫持，需要深度便利整个对象")]),e._v(" "),a("li",[e._v("对于数组不能监听到数据的变化")])]),e._v(" "),a("p",[e._v("反观Proxy，原生支持监听数组变化，并且可以直接对整个对象进行拦截")]),e._v(" "),a("h2",{attrs:{id:"virtual-dom算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom算法","aria-hidden":"true"}},[e._v("#")]),e._v(" Virtual Dom算法")]),e._v(" "),a("p",[e._v("时间复杂度o(n)")]),e._v(" "),a("p",[e._v("关键只对比同层的节点，而不是跨层对比")]),e._v(" "),a("p",[e._v("步骤：")]),e._v(" "),a("ol",[a("li",[e._v("首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异")]),e._v(" "),a("li",[e._v("一旦节点有子元素，就去判断子元素是否有不同")])])])}],!1,null,null,null);r.options.__file="Damn-hole-of-mvvm.md";t.default=r.exports}}]);